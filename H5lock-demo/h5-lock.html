<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style type="text/css">
        body {
            text-align: center;
            background-color: #566986;
        }
        .title {
            color: #50dfef;
            margin-top: 200px;
        }
        .resetPassword{
            position: absolute;
            text-decoration: underline;
            width:60px;left:50%;
            margin-left:-30px;
            color:#50dfef;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div style="position: absolute;top:0;left:0;right:0;bottom:0;">
        <h4 id="lock_title" class="title">绘制解锁图案</h4>
        <canvas id="canvas" width="350" height="300" style="background-color: #566986;display: inline-block;margin-top: 1px;"></canvas>
        <br>
        <a class="resetPassword" id="reset_password">重置密码</a>
    </div>
<script type="text/javascript">
        function getDis(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        };
    var Lock= function(){
        this.num_row = 3;
        this.title = document.getElementById('lock_title');
        this.reset_password = document.getElementById('reset_password');
        this.init = function(){
            this.pswObj = window.localStorage.getItem('password') ? {
                step: 2,
                password: JSON.parse(window.localStorage.getItem('password'))
            } : {};
            this.touchFlag = false;
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.createCircle();
            this.bindEvent();
        };
        this.createCircle = function(){
            var count = 0;
            this.r = this.ctx.canvas.width / (8 + 4 * this.num_row);// 公式计算
            this.lastPoint = [];
            this.circle_arr = [];
            this.restPoint = [];
            var r = this.r;
            for (var i = 0 ; i < this.num_row ; i++) {
                for (var j = 0 ; j < this.num_row ; j++) {
                    count++;
                    var obj = {
                        x: j * 4 * r + 6 * r,
                        y: i * 4 * r + 6 * r,
                        index: count
                    };
                    this.circle_arr.push(obj);
                    this.restPoint.push(obj);
                }
            }
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            for (var i = 0 ; i < this.circle_arr.length ; i++) {
                this.drawCle(this.circle_arr[i].x, this.circle_arr[i].y);
            }
        };
        this.drawCle = function(x, y) { 
            // 初始化解锁密码面板
            this.ctx.strokeStyle = '#CFE6FF';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(x, y, this.r, 0, Math.PI * 2, true);
            this.ctx.closePath();
            this.ctx.stroke();
        };
        this.bindEvent = function() {
            var self = this;
            this.canvas.addEventListener("touchstart", function (e) {
                 var xy = self.getPosition(e);
                 for (var i = 0 ; i < self.circle_arr.length ; i++) {
                    if (Math.abs(xy.x - self.circle_arr[i].x) < self.r && Math.abs(xy.y - self.circle_arr[i].y) < self.r) {

                        self.touchFlag = true;
                        self.drawPoint(self.circle_arr[i].x,self.circle_arr[i].y);
                        self.lastPoint.push(self.circle_arr[i]);
                        self.restPoint.splice(i,1);
                        self.update(self.getPosition(e));
                        break;
                    }
                 }
             }, false);
             this.canvas.addEventListener("touchmove", function (e) {
                if (self.touchFlag) {
                    self.update(self.getPosition(e));
                }
             }, false);
             this.canvas.addEventListener("touchend", function (e) {
                 if (self.touchFlag) {
                     self.touchFlag = false;
                     self.storePassword(self.lastPoint);
                     setTimeout(function(){
                        self.reset();
                    }, 300);
                 }
             }, false);
             this.reset_password.addEventListener('click', function(){
                 self.updatePassword();
              });
        };
        this.getPosition = function(e) {
            // 获取touch点相对于canvas的坐标
            var rect = e.currentTarget.getBoundingClientRect();
            var xy = {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
              };
            return xy;
        };
        this.drawPoint = function() { 
            // 初始化圆心
            for (var i = 0 ; i < this.lastPoint.length ; i++) {
                this.ctx.fillStyle = '#CFE6FF';
                this.ctx.beginPath();
                this.ctx.arc(this.lastPoint[i].x, this.lastPoint[i].y, this.r / 2, 0, Math.PI * 2, true);
                this.ctx.closePath();
                this.ctx.fill();
            }
        };
        this.update = function(xy) {
            // 核心变换方法在touchmove时候调用
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            for (var i = 0 ; i < this.circle_arr.length ; i++) { 
                // 每帧先把面板画出来
                this.drawCle(this.circle_arr[i].x, this.circle_arr[i].y);
            }
            this.drawPoint(this.lastPoint);// 每帧花轨迹
            this.drawLine(xy , this.lastPoint);// 每帧画圆心
            for (var i = 0 ; i < this.restPoint.length ; i++) {
                var pt = this.restPoint[i];
                if (Math.abs(xy.x - pt.x) < this.r && Math.abs(xy.y - pt.y) < this.r) {
                    this.drawPoint(pt.x, pt.y);
                    this.pickPoints(this.lastPoint[this.lastPoint.length - 1], pt);
                    break;
                }
            }
        };
        this.drawLine = function(xy, lastPoint) {
            // 解锁轨迹
            this.ctx.beginPath();
            this.ctx.lineWidth = 3;
            this.ctx.moveTo(this.lastPoint[0].x, this.lastPoint[0].y);
            console.log(this.lastPoint.length);
            for (var i = 1 ; i < this.lastPoint.length ; i++) {
                this.ctx.lineTo(this.lastPoint[i].x, this.lastPoint[i].y);
            }
            this.ctx.lineTo(xy.x, xy.y);
            this.ctx.stroke();
            this.ctx.closePath();

        };
        this.pickPoints = function(fromPoint, toPoint) {
            var lineLength = getDis(fromPoint, toPoint);
            var dir = toPoint.index > fromPoint.index ? 1 : -1;
            var len = this.restPoint.length;
            var i = dir === 1 ? 0 : (len - 1);
            var limit = dir === 1 ? len : -1;

            while (i !== limit) {
                var pt = this.restPoint[i];
                if (getDis(pt, fromPoint) + getDis(pt, toPoint) === lineLength) {
                    this.drawPoint(pt.x, pt.y);
                    this.lastPoint.push(pt);
                    this.restPoint.splice(i, 1);
                    if (limit > 0) {
                        i--;
                        limit--;
                    }
                }
                i+=dir;
            }
        };

        this.storePassword = function(psw) {
            // touchend结束之后存储密码
            if (this.pswObj.step == 1) {
                if (this.checkPassword(this.pswObj.setPassword, psw)) {
                    this.pswObj.step = 2;
                    this.pswObj.password = psw;
                    this.title.innerHTML = '密码保存成功';
                    this.drawStatusPoint('#2CFF26');
                    window.localStorage.setItem('password', JSON.stringify(this.pswObj.password));
                } else {
                    this.title.innerHTML = '两次不一致，重新输入';
                    this.drawStatusPoint('red');
                    delete this.pswObj.step;
                }
            } else if (this.pswObj.step == 2) {
                if (this.checkPassword(this.pswObj.password, psw)) {
                    this.title.innerHTML = '解锁成功';
                    this.drawStatusPoint('#2CFF26');
                } else {
                    this.drawStatusPoint('red');
                    this.title.innerHTML = '解锁失败';
                }
            } else {
                this.pswObj.step = 1;
                this.pswObj.setPassword = psw;
                this.title.innerHTML = '再次输入';
            }

        };
        this.checkPassword = function(psw1, psw2) {
            // 检测密码
            var p1 = '',p2 = '';
            for (var i = 0 ; i < psw1.length ; i++) {
                p1 += psw1[i].index + psw1[i].index;
            }
            for (var i = 0 ; i < psw2.length ; i++) {
                p2 += psw2[i].index + psw2[i].index;
            }
            return p1 === p2;
        };
        this.drawStatusPoint = function(type) { 
            // 初始化状态线条
            for (var i = 0 ; i < this.lastPoint.length ; i++) {
                this.ctx.strokeStyle = type;
                this.ctx.beginPath();
                this.ctx.arc(this.lastPoint[i].x, this.lastPoint[i].y, this.r, 0, Math.PI * 2, true);
                this.ctx.closePath();
                this.ctx.stroke();
            }
        };
        this.reset = function() {
            this.createCircle();
        };
        this.updatePassword = function(){
            window.localStorage.removeItem('password');
            this.pswObj = {};
            this.title.innerHTML = '绘制解锁图案';
            this.reset();
        };
    };
    var lock = new Lock();
    lock.init();
</script>
</body>
</html>